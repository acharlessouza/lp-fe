<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Liquidity Distribution Preview</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg-1: #0f1120;
        --bg-2: #1b1d35;
        --card: rgba(22, 24, 44, 0.85);
        --card-border: rgba(124, 140, 255, 0.25);
        --text: #f5f6ff;
        --muted: #9aa0c3;
        --accent: #41d9c1;
        --accent-2: #f4b95b;
        --bar: #7c8cff;
        --bar-dim: rgba(124, 140, 255, 0.25);
        --range: #3ee08f;
        --current: rgba(124, 140, 255, 0.8);
        --price-current: #f16aa7;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", sans-serif;
        background: radial-gradient(circle at top, #1b2448 0%, var(--bg-1) 45%, #0b0d18 100%);
        color: var(--text);
      }

      .page {
        min-height: 100vh;
        padding: 48px 20px 80px;
        display: flex;
        justify-content: center;
      }

      .wrap {
        width: min(1200px, 100%);
      }

      #root {
        display: grid;
        grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
        align-items: start;
        gap: 24px;
      }

      .stack {
        display: grid;
        gap: 20px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }

      .title {
        font-size: 28px;
        font-weight: 600;
        letter-spacing: -0.02em;
      }

      .subtitle {
        color: var(--muted);
        font-size: 14px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--card-border);
        border-radius: 18px;
        padding: 24px;
        box-shadow: 0 20px 40px rgba(6, 8, 20, 0.4);
      }

      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        margin-bottom: 12px;
      }

      .chart-title {
        font-size: 18px;
        font-weight: 600;
      }

      .axis-labels {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }

      .chart-meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 6px;
        color: var(--muted);
        font-size: 14px;
      }

      .chart-meta .price {
        font-size: 16px;
        color: var(--text);
      }

      .range-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .range-controls input {
        width: 120px;
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(12, 14, 28, 0.6);
        color: var(--text);
        font-family: inherit;
        font-size: 13px;
      }

      .range-controls button {
        padding: 6px 12px;
        border-radius: 8px;
        border: 1px solid rgba(124, 140, 255, 0.45);
        background: rgba(124, 140, 255, 0.2);
        color: var(--text);
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
      }

      .deposit-card {
        display: grid;
        gap: 18px;
      }

      .deposit-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .deposit-title {
        font-size: 16px;
        font-weight: 600;
      }

      .deposit-input {
        display: grid;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
      }

      .deposit-input input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(12, 14, 28, 0.6);
        color: var(--text);
        font-family: inherit;
        font-size: 15px;
      }

      .split-labels {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--muted);
      }

      .action-button {
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid rgba(124, 140, 255, 0.45);
        background: linear-gradient(135deg, rgba(124, 140, 255, 0.25), rgba(65, 217, 193, 0.18));
        color: var(--text);
        font-family: inherit;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
      }

      .ghost-button {
        background: rgba(12, 14, 28, 0.6);
        border-color: rgba(124, 140, 255, 0.25);
      }

      .fees-card {
        display: grid;
        gap: 16px;
      }

      .fees-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }

      .fees-title {
        font-size: 13px;
        color: var(--muted);
      }

      .fees-title span {
        color: var(--muted);
      }

      .fees-value {
        font-size: 24px;
        font-weight: 600;
        margin-top: 6px;
      }

      .fees-chip {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        color: var(--accent);
        background: rgba(65, 217, 193, 0.15);
        border: 1px solid rgba(65, 217, 193, 0.35);
      }

      .fees-rows {
        display: grid;
        gap: 10px;
      }

      .fees-row {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--muted);
      }

      .fees-row strong {
        color: var(--text);
        font-weight: 600;
      }

      .range-card {
        display: grid;
        gap: 14px;
      }

      .range-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }

      .range-title {
        font-size: 16px;
        font-weight: 600;
      }

      .range-subtitle {
        color: var(--muted);
        font-size: 12px;
        margin-top: 4px;
      }

      .range-badges {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 6px;
      }

      .chip {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        border: 1px solid rgba(124, 140, 255, 0.3);
        background: rgba(124, 140, 255, 0.18);
        color: var(--text);
        cursor: pointer;
      }

      .chip.is-active {
        border-color: rgba(65, 217, 193, 0.45);
        background: rgba(65, 217, 193, 0.2);
        color: var(--text);
      }

      .range-meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }

      .range-meta-card {
        display: grid;
        gap: 8px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(12, 14, 28, 0.6);
        border: 1px solid rgba(124, 140, 255, 0.15);
      }

      .range-meta-card span {
        color: var(--muted);
        font-size: 11px;
      }

      .range-meta-card strong {
        font-size: 13px;
      }

      .timeframe-controls {
        display: grid;
        grid-template-columns: 32px minmax(0, 1fr) 32px;
        gap: 8px;
        align-items: center;
      }

      .timeframe-controls button {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px solid rgba(124, 140, 255, 0.3);
        background: rgba(12, 14, 28, 0.6);
        color: var(--text);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
      }

      .timeframe-controls input {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(12, 14, 28, 0.6);
        color: var(--text);
        font-family: inherit;
        font-size: 13px;
        text-align: center;
      }

      .range-inputs {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
      }

      .range-inputs label {
        display: grid;
        gap: 6px;
        font-size: 11px;
        color: var(--muted);
      }

      .range-inputs input {
        width: 100%;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(12, 14, 28, 0.6);
        color: var(--text);
        font-family: inherit;
        font-size: 13px;
      }

      .range-slider {
        position: relative;
        height: 10px;
        border-radius: 999px;
        background: rgba(124, 140, 255, 0.2);
      }

      .range-sliders {
        position: relative;
        height: 28px;
        display: grid;
        align-items: center;
      }

      .range-sliders input[type="range"] {
        position: absolute;
        left: 0;
        right: 0;
        width: 100%;
        margin: 0;
        appearance: none;
        height: 10px;
        background: transparent;
        pointer-events: none;
      }

      .range-sliders input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--text);
        border: 2px solid var(--range);
        pointer-events: auto;
        cursor: pointer;
      }

      .range-sliders input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--text);
        border: 2px solid var(--range);
        pointer-events: auto;
        cursor: pointer;
      }

      .range-fill {
        position: absolute;
        top: 0;
        bottom: 0;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(65, 217, 193, 0.45), rgba(124, 140, 255, 0.6));
      }

      .range-handle {
        position: absolute;
        top: 50%;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: var(--text);
        border: 2px solid var(--range);
        transform: translate(-50%, -50%);
      }

      .range-values {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--muted);
      }

      .pool-price-card {
        display: grid;
        gap: 16px;
      }

      .price-title {
        font-size: 18px;
        font-weight: 600;
      }

      .price-stats {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 12px;
      }

      .stat-card {
        padding: 10px 12px;
        border-radius: 12px;
        background: rgba(12, 14, 28, 0.55);
        border: 1px solid rgba(124, 140, 255, 0.15);
        display: grid;
        gap: 6px;
      }

      .stat-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .stat-value {
        font-size: 16px;
        font-weight: 600;
      }

      .price-chart {
        position: relative;
        margin-top: 8px;
      }

      .price-line--min,
      .price-line--max {
        stroke: var(--range);
        stroke-dasharray: 6 6;
        opacity: 0.75;
      }

      .price-line--current {
        stroke: var(--price-current);
        stroke-dasharray: 6 6;
        opacity: 0.85;
      }

      .price-axis {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--muted);
        margin-top: 8px;
      }

      .token-rows {
        display: grid;
        gap: 12px;
      }

      .token-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        border-radius: 10px;
        background: rgba(12, 14, 28, 0.5);
        border: 1px solid rgba(124, 140, 255, 0.15);
      }

      .token-row span {
        color: var(--muted);
        font-size: 12px;
      }

      .token-value {
        text-align: right;
      }

      .token-value strong {
        display: block;
        color: var(--text);
        font-size: 14px;
      }

      .chart-meta .lock {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .chart-meta .lock::after {
        content: "ðŸ”’";
        font-size: 12px;
      }

      .zoom-controls {
        display: flex;
        gap: 8px;
      }

      .zoom-controls button {
        width: 30px;
        height: 30px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(12, 14, 28, 0.7);
        color: var(--text);
        cursor: pointer;
        font-weight: 600;
      }

      .legend {
        display: flex;
        gap: 16px;
        font-size: 12px;
        color: var(--muted);
      }

      .legend span::before {
        content: "";
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-right: 6px;
        border-radius: 999px;
        vertical-align: middle;
      }

      .legend .range::before {
        background: var(--range);
      }

      .legend .liquidity::before {
        background: var(--bar);
      }

      .chart-shell {
        position: relative;
      }

      .hover-line {
        position: absolute;
        top: 86px;
        bottom: 48px;
        width: 1px;
        background: rgba(255, 255, 255, 0.2);
        pointer-events: none;
      }

      .tooltip {
        position: absolute;
        top: 12px;
        transform: translateX(-50%);
        background: rgba(15, 17, 32, 0.92);
        border: 1px solid rgba(124, 140, 255, 0.35);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 12px;
        color: var(--text);
        pointer-events: none;
        box-shadow: 0 12px 20px rgba(5, 8, 20, 0.4);
        min-width: 160px;
      }

      .tooltip .label {
        color: var(--muted);
        font-size: 11px;
        margin-bottom: 4px;
      }

      @media (max-width: 960px) {
        #root {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 720px) {
        .range-meta,
        .range-inputs {
          grid-template-columns: 1fr;
        }

        .price-stats {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="wrap">
        <div id="root"></div>
      </div>
    </div>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      const REQUEST = {
        poolId: 572,
        poolAddress: "0x4e68ccd3e89f51c3074ca5072bbac773960dfa36",
        rede: "ethereum",
        snapshotDate: "2025-12-24",
        currentTick: 0,
        tickRange: 6000,
      };

      function LiquidityChart({
        apiData,
        loading,
        error,
        rangeMin,
        rangeMax,
        setRangeMin,
        setRangeMax,
        onApply,
      }) {
        const [hoverIndex, setHoverIndex] = useState(null);

        const points = useMemo(() => {
          if (!apiData?.data?.length) return [];
          return apiData.data
            .map((point) => ({
              tick: Number(point.tick),
              liquidity: String(point.liquidity),
              liquidityValue: Number(point.liquidity),
              price: Number(point.price),
            }))
            .sort((a, b) => a.tick - b.tick);
        }, [apiData]);

        const token0 = apiData?.pool?.token0 || "TOKEN0";
        const token1 = apiData?.pool?.token1 || "TOKEN1";
        const currentTick = apiData?.current_tick ?? REQUEST.currentTick;
        const rangeMinValue = Number.isFinite(Number(rangeMin)) ? Number(rangeMin) : null;
        const rangeMaxValue = Number.isFinite(Number(rangeMax)) ? Number(rangeMax) : null;
        const hasRange = rangeMinValue !== null && rangeMaxValue !== null;
        const rangeLow = hasRange ? Math.min(rangeMinValue, rangeMaxValue) : null;
        const rangeHigh = hasRange ? Math.max(rangeMinValue, rangeMaxValue) : null;

        const defaultIndex = useMemo(() => {
          if (!points.length) return null;
          let bestIndex = 0;
          let bestDistance = Math.abs(points[0].tick - currentTick);
          points.forEach((point, idx) => {
            const distance = Math.abs(point.tick - currentTick);
            if (distance < bestDistance) {
              bestDistance = distance;
              bestIndex = idx;
            }
          });
          return bestIndex;
        }, [points, currentTick]);

        const hoverPoint =
          hoverIndex !== null && points[hoverIndex] ? points[hoverIndex] : points[defaultIndex];

        const minTick = points.length ? points[0].tick : currentTick - REQUEST.tickRange;
        const maxTick = points.length ? points[points.length - 1].tick : currentTick + REQUEST.tickRange;
        const maxLiquidity = points.length
          ? Math.max(...points.map((point) => point.liquidityValue))
          : 0;
        const displayPrice = hoverPoint ? hoverPoint.price : 0;

        const width = 820;
        const height = 260;
        const padding = 24;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;
        const barWidth = points.length ? chartWidth / points.length : chartWidth;

        const scaleX = (tick) => {
          if (maxTick === minTick) return padding;
          const ratio = (tick - minTick) / (maxTick - minTick);
          return padding + ratio * chartWidth;
        };

        const handleMouseMove = (event) => {
          if (!points.length) return;
          const rect = event.currentTarget.getBoundingClientRect();
          const paddingPx = (padding / width) * rect.width;
          const innerWidth = rect.width - paddingPx * 2;
          const x = Math.min(innerWidth, Math.max(0, event.clientX - rect.left - paddingPx));
          const idx = Math.round((x / innerWidth) * (points.length - 1));
          setHoverIndex(idx);
        };

        return (
          <div className="card">
            <div className="chart-header">
              <div>
                <div className="chart-title">Liquidity Distribution</div>
                <div className="chart-meta">
                  <div className="price">
                    1 {token0} = {hoverPoint ? hoverPoint.price.toFixed(2) : "..."} {token1}
                  </div>
                  <div className="range-controls">
                    <label>
                      Range min
                      <input
                        value={rangeMin}
                        onChange={(event) => setRangeMin(event.target.value)}
                      />
                    </label>
                    <label>
                      Range max
                      <input
                        value={rangeMax}
                        onChange={(event) => setRangeMax(event.target.value)}
                      />
                    </label>
                    <button onClick={onApply}>Apply</button>
                  </div>
                </div>
              </div>
              <div className="subtitle">{loading ? "Loading..." : error ? "API error" : ""}</div>
            </div>

            <div className="chart-shell">
              <svg
                width="100%"
                viewBox={`0 0 ${width} ${height}`}
                onMouseMove={handleMouseMove}
                onMouseLeave={() => setHoverIndex(null)}
              >
                <rect
                  x="0"
                  y="0"
                  width={width}
                  height={height}
                  rx="14"
                  fill="rgba(10, 12, 26, 0.7)"
                />
                {points.map((point, idx) => {
                  const heightScale = maxLiquidity > 0 ? point.liquidityValue / maxLiquidity : 0;
                  const barHeight = heightScale * chartHeight;
                  const x = scaleX(point.tick) - barWidth / 2;
                  const y = height - padding - barHeight;
                  return (
                    <rect
                      key={point.tick}
                      x={x}
                      y={y}
                      width={Math.max(1, barWidth * 0.9)}
                      height={barHeight}
                      fill="var(--bar)"
                      opacity={hoverIndex === idx ? 0.9 : 0.6}
                    />
                  );
                })}
                {hasRange && points.length ? (
                  <line
                    x1={scaleX(
                      points.reduce((closest, point) =>
                        Math.abs(point.price - rangeLow) <
                        Math.abs(closest.price - rangeLow)
                          ? point
                          : closest
                      ).tick
                    )}
                    x2={scaleX(
                      points.reduce((closest, point) =>
                        Math.abs(point.price - rangeLow) <
                        Math.abs(closest.price - rangeLow)
                          ? point
                          : closest
                      ).tick
                    )}
                    y1={padding}
                    y2={height - padding}
                    stroke="var(--range)"
                    strokeWidth="2"
                  />
                ) : null}
                {hasRange && points.length ? (
                  <line
                    x1={scaleX(
                      points.reduce((closest, point) =>
                        Math.abs(point.price - rangeHigh) <
                        Math.abs(closest.price - rangeHigh)
                          ? point
                          : closest
                      ).tick
                    )}
                    x2={scaleX(
                      points.reduce((closest, point) =>
                        Math.abs(point.price - rangeHigh) <
                        Math.abs(closest.price - rangeHigh)
                          ? point
                          : closest
                      ).tick
                    )}
                    y1={padding}
                    y2={height - padding}
                    stroke="var(--range)"
                    strokeWidth="2"
                  />
                ) : null}
                <line
                  x1={scaleX(currentTick)}
                  x2={scaleX(currentTick)}
                  y1={padding}
                  y2={height - padding}
                  stroke="var(--current)"
                  strokeWidth="1"
                />
              </svg>
              {hoverPoint ? (
                <div className="tooltip" style={{ left: `${scaleX(hoverPoint.tick)}px` }}>
                  <div className="label">
                    1 {token0} = {hoverPoint.price.toFixed(2)} {token1}
                  </div>
                </div>
              ) : null}
            </div>

            <div className="axis-labels">
              <span>{minTick}</span>
              <span>{points.length ? "Distribution" : "No data"}</span>
              <span>{maxTick}</span>
            </div>
          </div>
        );
      }

      function PoolPriceChart({
        apiData,
        loading,
        error,
        rangeMin,
        rangeMax,
        token0,
        token1,
      }) {
        const [hoverIndex, setHoverIndex] = useState(null);

        const points = useMemo(() => {
          if (!apiData?.series?.length) return [];
          return apiData.series
            .map((point) => {
              const ts = new Date(point.timestamp);
              return {
                timestamp: point.timestamp,
                tsMs: Number.isFinite(ts.getTime()) ? ts.getTime() : null,
                price: Number(point.price),
              };
            })
            .filter((point) => Number.isFinite(point.tsMs) && Number.isFinite(point.price))
            .sort((a, b) => a.tsMs - b.tsMs);
        }, [apiData]);

        const stats = apiData?.stats || {};
        const statMin = Number(stats.min);
        const statMax = Number(stats.max);
        const statAvg = Number(stats.avg);
        const statPrice = Number(stats.price);

        const minInput = Number(rangeMin);
        const maxInput = Number(rangeMax);

        const seriesPrices = points.map((point) => point.price);
        const fallbackPrices = [statPrice, minInput, maxInput].filter((value) => Number.isFinite(value));
        const pricesForScale = seriesPrices.length ? seriesPrices : fallbackPrices;
        let minPrice = pricesForScale.length ? Math.min(...pricesForScale) : 0;
        let maxPrice = pricesForScale.length ? Math.max(...pricesForScale) : 1;
        if (minPrice === maxPrice) {
          minPrice -= 1;
          maxPrice += 1;
        }

        const minTs = points.length ? points[0].tsMs : 0;
        const maxTs = points.length ? points[points.length - 1].tsMs : 1;

        const width = 820;
        const height = 260;
        const padding = 24;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;
        const baseY = height - padding;

        const scaleX = (timestamp) => {
          if (maxTs === minTs) return padding;
          const ratio = (timestamp - minTs) / (maxTs - minTs);
          return padding + ratio * chartWidth;
        };

        const scaleY = (price) => {
          if (maxPrice === minPrice) return height / 2;
          const ratio = (price - minPrice) / (maxPrice - minPrice);
          return height - padding - ratio * chartHeight;
        };

        const clampY = (value) => Math.min(baseY, Math.max(padding, value));

        const linePath = points.length
          ? points
              .map((point, idx) => {
                const command = idx === 0 ? "M" : "L";
                return `${command} ${scaleX(point.tsMs)} ${scaleY(point.price)}`;
              })
              .join(" ")
          : "";

        const areaPath = points.length
          ? [
              `M ${scaleX(points[0].tsMs)} ${baseY}`,
              `L ${scaleX(points[0].tsMs)} ${scaleY(points[0].price)}`,
              ...points.slice(1).map((point) => `L ${scaleX(point.tsMs)} ${scaleY(point.price)}`),
              `L ${scaleX(points[points.length - 1].tsMs)} ${baseY}`,
              "Z",
            ].join(" ")
          : "";

        const handleMouseMove = (event) => {
          if (!points.length) return;
          const rect = event.currentTarget.getBoundingClientRect();
          const paddingPx = (padding / width) * rect.width;
          const innerWidth = rect.width - paddingPx * 2;
          const x = Math.min(innerWidth, Math.max(0, event.clientX - rect.left - paddingPx));
          const ratio = innerWidth > 0 ? x / innerWidth : 0;
          const hoverTime = minTs + ratio * (maxTs - minTs);
          let closestIndex = 0;
          let bestDistance = Math.abs(points[0].tsMs - hoverTime);
          points.forEach((point, idx) => {
            const distance = Math.abs(point.tsMs - hoverTime);
            if (distance < bestDistance) {
              bestDistance = distance;
              closestIndex = idx;
            }
          });
          setHoverIndex(closestIndex);
        };

        const hoverPoint =
          hoverIndex !== null && points[hoverIndex] ? points[hoverIndex] : points[points.length - 1];

        const formatDateTime = (timestamp) => {
          if (!timestamp) return "--";
          const date = new Date(timestamp);
          if (!Number.isFinite(date.getTime())) return "--";
          const pad = (value) => String(value).padStart(2, "0");
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(
            date.getDate()
          )} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        };

        const formatStat = (value) => (Number.isFinite(value) ? value.toFixed(2) : "--");

        const axisStart = points.length ? formatDateTime(points[0].timestamp) : "No data";
        const axisEnd = points.length ? formatDateTime(points[points.length - 1].timestamp) : "--";

        return (
          <div className="card pool-price-card">
            <div className="chart-header">
              <div>
                <div className="price-title">Pool Price</div>
                <div className="subtitle">
                  1 {token0} = {Number.isFinite(statPrice) ? statPrice.toFixed(2) : "--"} {token1}
                </div>
              </div>
              <div className="subtitle">{loading ? "Loading..." : error ? "API error" : ""}</div>
            </div>
            <div className="price-stats">
              <div className="stat-card">
                <span className="stat-label">MIN</span>
                <span className="stat-value">{formatStat(statMin)}</span>
              </div>
              <div className="stat-card">
                <span className="stat-label">PRICE</span>
                <span className="stat-value">{formatStat(statPrice)}</span>
              </div>
              <div className="stat-card">
                <span className="stat-label">AVG</span>
                <span className="stat-value">{formatStat(statAvg)}</span>
              </div>
              <div className="stat-card">
                <span className="stat-label">MAX</span>
                <span className="stat-value">{formatStat(statMax)}</span>
              </div>
            </div>
            <div className="price-chart">
              <svg
                width="100%"
                viewBox={`0 0 ${width} ${height}`}
                onMouseMove={handleMouseMove}
                onMouseLeave={() => setHoverIndex(null)}
              >
                <defs>
                  <linearGradient id="priceFill" x1="0" x2="0" y1="0" y2="1">
                    <stop offset="0%" stopColor="rgba(124, 140, 255, 0.45)" />
                    <stop offset="100%" stopColor="rgba(124, 140, 255, 0.05)" />
                  </linearGradient>
                </defs>
                <rect
                  x="0"
                  y="0"
                  width={width}
                  height={height}
                  rx="14"
                  fill="rgba(10, 12, 26, 0.7)"
                />
                {Number.isFinite(minInput) ? (
                  <line
                    x1={padding}
                    x2={width - padding}
                    y1={clampY(scaleY(minInput))}
                    y2={clampY(scaleY(minInput))}
                    className="price-line--min"
                    strokeWidth="1.5"
                  />
                ) : null}
                {Number.isFinite(maxInput) ? (
                  <line
                    x1={padding}
                    x2={width - padding}
                    y1={clampY(scaleY(maxInput))}
                    y2={clampY(scaleY(maxInput))}
                    className="price-line--max"
                    strokeWidth="1.5"
                  />
                ) : null}
                {Number.isFinite(statPrice) ? (
                  <line
                    x1={padding}
                    x2={width - padding}
                    y1={clampY(scaleY(statPrice))}
                    y2={clampY(scaleY(statPrice))}
                    className="price-line--current"
                    strokeWidth="1.5"
                  />
                ) : null}
                {areaPath ? <path d={areaPath} fill="url(#priceFill)" /> : null}
                {linePath ? (
                  <path d={linePath} fill="none" stroke="var(--bar)" strokeWidth="2" />
                ) : null}
              </svg>
              {hoverPoint ? (
                <div className="tooltip" style={{ left: `${scaleX(hoverPoint.tsMs)}px` }}>
                  <div className="label">
                    1 {token0} = {hoverPoint.price.toFixed(2)} {token1}
                  </div>
                  <div>{formatDateTime(hoverPoint.timestamp)}</div>
                </div>
              ) : null}
            </div>
            <div className="price-axis">
              <span>{axisStart}</span>
              <span>{axisEnd}</span>
            </div>
          </div>
        );
      }

      function EstimatedFees() {
        return (
          <div className="card fees-card">
            <div className="fees-header">
              <div>
                <div className="fees-title">
                  Estimated Fees <span>(24h)</span>
                </div>
                <div className="fees-value">$3.744</div>
              </div>
              <div className="fees-chip">Fee APR 12.92%</div>
            </div>
            <div className="fees-rows">
              <div className="fees-row">
                <span>Volume (24h)</span>
                <strong>$9.05M</strong>
              </div>
              <div className="fees-row">
                <span>Fees (24h)</span>
                <strong>$3.78</strong>
              </div>
              <div className="fees-row">
                <span>Pool APR</span>
                <strong>12.92%</strong>
              </div>
            </div>
            <button className="action-button ghost-button" type="button">
              Simulate Position Performance
            </button>
          </div>
        );
      }

      function LiquidityPriceRange({
        rangeMin,
        rangeMax,
        setRangeMin,
        setRangeMax,
        onApply,
        bounds,
        timeframeDays,
        setTimeframeDays,
        feeTier,
        token0Decimals,
        token1Decimals,
      }) {
        const fallbackFeeTier = 3000;
        const fallbackToken0Decimals = 18;
        const fallbackToken1Decimals = 6;
        const resolvedFeeTier = Number.isFinite(Number(feeTier))
          ? Number(feeTier)
          : fallbackFeeTier;
        const resolvedToken0Decimals = Number.isFinite(Number(token0Decimals))
          ? Number(token0Decimals)
          : fallbackToken0Decimals;
        const resolvedToken1Decimals = Number.isFinite(Number(token1Decimals))
          ? Number(token1Decimals)
          : fallbackToken1Decimals;
        const parsedMin = Number(rangeMin);
        const parsedMax = Number(rangeMax);
        const minBound = Number.isFinite(bounds?.min) ? bounds.min : null;
        const maxBound = Number.isFinite(bounds?.max) ? bounds.max : null;
        const hasBounds = Number.isFinite(minBound) && Number.isFinite(maxBound) && maxBound !== minBound;
        let lowPercent = 0.18;
        let highPercent = 0.82;
        const tickSpacingMap = {
          100: 1,
          500: 10,
          3000: 60,
          10000: 200,
        };
        const tickSpacing = tickSpacingMap[resolvedFeeTier] ?? 1;
        const decimalAdjust = Math.pow(10, resolvedToken0Decimals - resolvedToken1Decimals);
        const minTick = -887272;
        const maxTick = 887272;

        const handleTimeframeChange = (value) => {
          const parsed = Number(value);
          if (!Number.isFinite(parsed)) {
            return;
          }
          const clamped = Math.min(365, Math.max(1, Math.round(parsed)));
          setTimeframeDays(clamped);
        };

        const step = 0.01;

        const formatRangeValue = (value) => {
          if (!Number.isFinite(value)) {
            return "";
          }
          return value.toFixed(6);
        };

        const getSafeValue = (value, fallback) => {
          if (Number.isFinite(value)) {
            return value;
          }
          if (Number.isFinite(fallback)) {
            return fallback;
          }
          return 0;
        };

        const snapPriceToTick = (price, roundDown) => {
          if (!Number.isFinite(price) || price <= 0 || !Number.isFinite(tickSpacing) || tickSpacing <= 0) {
            return null;
          }
          const adjustedPrice = price / decimalAdjust;
          if (!Number.isFinite(adjustedPrice) || adjustedPrice <= 0) {
            return null;
          }
          const rawTick = Math.log(adjustedPrice) / Math.log(1.0001);
          if (!Number.isFinite(rawTick)) {
            return null;
          }
          const snappedTick = roundDown
            ? Math.floor(rawTick / tickSpacing) * tickSpacing
            : Math.ceil(rawTick / tickSpacing) * tickSpacing;
          const clampedTick = Math.min(maxTick, Math.max(minTick, snappedTick));
          const snappedPrice = Math.pow(1.0001, clampedTick) * decimalAdjust;
          return Number.isFinite(snappedPrice) ? snappedPrice : null;
        };

        const updateRangeValue = (value, roundDown) => {
          if (value === "") {
            return value;
          }
          const parsed = Number(value);
          if (!Number.isFinite(parsed)) {
            return value;
          }
          const snapped = snapPriceToTick(parsed, roundDown);
          if (snapped === null) {
            return value;
          }
          const clamped =
            hasBounds && Number.isFinite(minBound) && Number.isFinite(maxBound)
              ? Math.min(maxBound, Math.max(minBound, snapped))
              : snapped;
          return formatRangeValue(clamped);
        };

        const commitRangeValue = (value, roundDown, setter) => {
          if (value === "") {
            return;
          }
          const parsed = Number(value);
          if (!Number.isFinite(parsed)) {
            return;
          }
          const snapped = snapPriceToTick(parsed, roundDown);
          const nextValue = snapped === null ? parsed : snapped;
          const clamped =
            hasBounds && Number.isFinite(minBound) && Number.isFinite(maxBound)
              ? Math.min(maxBound, Math.max(minBound, nextValue))
              : nextValue;
          setter(formatRangeValue(clamped));
        };

        if (hasBounds && Number.isFinite(parsedMin) && Number.isFinite(parsedMax)) {
          const low = Math.min(parsedMin, parsedMax);
          const high = Math.max(parsedMin, parsedMax);
          const clamp = (value) => Math.min(maxBound, Math.max(minBound, value));
          const clampedLow = clamp(low);
          const clampedHigh = clamp(high);
          lowPercent = (clampedLow - minBound) / (maxBound - minBound);
          highPercent = (clampedHigh - minBound) / (maxBound - minBound);
        }

        const displayMin =
          Number.isFinite(parsedMin) ? parsedMin : Number.isFinite(minBound) ? minBound : 0;
        const displayMax =
          Number.isFinite(parsedMax) ? parsedMax : Number.isFinite(maxBound) ? maxBound : 0;
        const lowPercentClamped = Math.max(0, Math.min(100, lowPercent * 100));
        const highPercentClamped = Math.max(0, Math.min(100, highPercent * 100));
        const safeMin = getSafeValue(parsedMin, minBound);
        const safeMax = getSafeValue(parsedMax, maxBound);
        const sliderMin = Math.min(safeMin, safeMax);
        const sliderMax = Math.max(safeMin, safeMax);

        return (
          <div className="card range-card">
            <input type="hidden" name="fee_tier" value={resolvedFeeTier} />
            <input type="hidden" name="token0_decimals" value={resolvedToken0Decimals} />
            <input type="hidden" name="token1_decimals" value={resolvedToken1Decimals} />
            <div className="range-header">
              <div>
                <div className="range-title">Liquidity Price Range</div>
                <div className="range-subtitle">Suggested range for balanced exposure</div>
              </div>
              <div className="range-badges">
                <button className="chip is-active" type="button">
                  Most Ticks
                </button>
                <button className="chip" type="button">
                  Full Range
                </button>
              </div>
            </div>
            <div className="range-meta">
              <div className="range-meta-card">
                <span>Calculation Timeframe (Days)</span>
                <div className="timeframe-controls">
                  <button
                    type="button"
                    onClick={() => handleTimeframeChange(timeframeDays - 1)}
                  >
                    -
                  </button>
                  <input
                    type="number"
                    min="1"
                    max="365"
                    value={timeframeDays}
                    onChange={(event) => handleTimeframeChange(event.target.value)}
                  />
                  <button
                    type="button"
                    onClick={() => handleTimeframeChange(timeframeDays + 1)}
                  >
                    +
                  </button>
                </div>
              </div>
              <div className="range-meta-card">
                <span>Calculation Method</span>
                <strong>Average Liquidity (Simple)</strong>
              </div>
            </div>
            <div className="range-inputs">
              <label>
                Min Price
                <input
                  value={rangeMin}
                  onChange={(event) => setRangeMin(event.target.value)}
                  onBlur={(event) => commitRangeValue(event.target.value, true, setRangeMin)}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      event.currentTarget.blur();
                    }
                  }}
                />
              </label>
              <label>
                Max Price
                <input
                  value={rangeMax}
                  onChange={(event) => setRangeMax(event.target.value)}
                  onBlur={(event) => commitRangeValue(event.target.value, false, setRangeMax)}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      event.currentTarget.blur();
                    }
                  }}
                />
              </label>
            </div>
            <div className="range-sliders">
              <div className="range-slider">
                <div
                  className="range-fill"
                  style={{
                    left: `${lowPercentClamped}%`,
                    right: `${Math.max(0, Math.min(100, 100 - highPercentClamped))}%`,
                  }}
                ></div>
                <div className="range-handle" style={{ left: `${lowPercentClamped}%` }}></div>
                <div className="range-handle" style={{ left: `${highPercentClamped}%` }}></div>
              </div>
              <input
                type="range"
                min={hasBounds ? minBound : 0}
                max={hasBounds ? maxBound : 100}
                step={step}
                value={sliderMin}
                onChange={(event) => {
                  const value = Number(event.target.value);
                  if (!Number.isFinite(value)) return;
                  const snapped = snapPriceToTick(value, true);
                  const nextValue =
                    snapped === null
                      ? value
                      : hasBounds && Number.isFinite(minBound) && Number.isFinite(maxBound)
                        ? Math.min(maxBound, Math.max(minBound, snapped))
                        : snapped;
                  if (Number.isFinite(parsedMax) && nextValue > parsedMax) {
                    setRangeMax(formatRangeValue(nextValue));
                  }
                  setRangeMin(formatRangeValue(nextValue));
                }}
                disabled={!hasBounds}
              />
              <input
                type="range"
                min={hasBounds ? minBound : 0}
                max={hasBounds ? maxBound : 100}
                step={step}
                value={sliderMax}
                onChange={(event) => {
                  const value = Number(event.target.value);
                  if (!Number.isFinite(value)) return;
                  const snapped = snapPriceToTick(value, false);
                  const nextValue =
                    snapped === null
                      ? value
                      : hasBounds && Number.isFinite(minBound) && Number.isFinite(maxBound)
                        ? Math.min(maxBound, Math.max(minBound, snapped))
                        : snapped;
                  if (Number.isFinite(parsedMin) && nextValue < parsedMin) {
                    setRangeMin(formatRangeValue(nextValue));
                  }
                  setRangeMax(formatRangeValue(nextValue));
                }}
                disabled={!hasBounds}
              />
            </div>
            <div className="range-values">
              <span>${displayMin.toFixed(2)}</span>
              <span>${displayMax.toFixed(2)}</span>
            </div>
            <button className="action-button" onClick={onApply} type="button">
              Apply Range
            </button>
          </div>
        );
      }

      function DepositAmount({
        token0,
        token1,
        depositUsd,
        setDepositUsd,
        allocateData,
        loading,
        error,
        onCalculate,
      }) {
        const parsedDeposit = Number(depositUsd);
        const totalUsd = Number.isFinite(parsedDeposit) ? parsedDeposit : 0;
        const amount0 = allocateData ? Number(allocateData.amount_token0) : 0;
        const amount1 = allocateData ? Number(allocateData.amount_token1) : 0;
        const price0 = allocateData ? Number(allocateData.price_token0_usd) : 0;
        const price1 = allocateData ? Number(allocateData.price_token1_usd) : 0;
        const token0Usd = amount0 * price0;
        const token1Usd = amount1 * price1;

        return (
          <div className="card deposit-card">
            <div className="deposit-header">
              <div className="deposit-title">Deposit Amount</div>
              <span className="subtitle">{loading ? "Calculating..." : error ? "Error" : ""}</span>
            </div>
            <div className="deposit-input">
              <label>Total deposit (USD)</label>
              <input
                value={depositUsd}
                onChange={(event) => setDepositUsd(event.target.value)}
                placeholder="1000"
              />
            </div>
            <button className="action-button" onClick={onCalculate} type="button">
              Calculate
            </button>
            <div className="token-rows">
              <div className="token-row">
                <div>
                  {token0}
                  <span>Amount</span>
                </div>
                <div className="token-value">
                  <strong>{amount0.toFixed(6)}</strong>
                  <span>${token0Usd.toFixed(2)}</span>
                </div>
              </div>
              <div className="token-row">
                <div>
                  {token1}
                  <span>Amount</span>
                </div>
                <div className="token-value">
                  <strong>{amount1.toFixed(6)}</strong>
                  <span>${token1Usd.toFixed(2)}</span>
                </div>
              </div>
            </div>
            <div className="split-labels">
              <span>Input USD: ${totalUsd.toFixed(2)}</span>
              <span>Output USD: ${(token0Usd + token1Usd).toFixed(2)}</span>
            </div>
          </div>
        );
      }

      function Page() {
        const [distributionData, setDistributionData] = useState(null);
        const [distributionLoading, setDistributionLoading] = useState(false);
        const [distributionError, setDistributionError] = useState("");
        const [poolPriceData, setPoolPriceData] = useState(null);
        const [poolPriceLoading, setPoolPriceLoading] = useState(false);
        const [poolPriceError, setPoolPriceError] = useState("");
        const [allocateData, setAllocateData] = useState(null);
        const [allocateLoading, setAllocateLoading] = useState(false);
        const [allocateError, setAllocateError] = useState("");
        const [rangeMin, setRangeMin] = useState("2833.5");
        const [rangeMax, setRangeMax] = useState("3242.4");
        const [depositUsd, setDepositUsd] = useState("1000");
        const [timeframeDays, setTimeframeDays] = useState(14);
        const allocateDebounceRef = useRef(null);
        const hasMountedRef = useRef(false);

        const apiUrl = "http://localhost:8000/api/liquidity-distribution";
        const poolPriceUrl = "http://localhost:8000/api/pool-price";
        const allocateUrl = "http://localhost:8000/v1/allocate";
        const token = "dev-token";

        const fetchDistribution = async () => {
          setDistributionLoading(true);
          setDistributionError("");
          try {
            const parsedMin = Number(rangeMin);
            const parsedMax = Number(rangeMax);
            const payload = {
              pool_id: REQUEST.poolId,
              snapshot_date: REQUEST.snapshotDate,
              current_tick: REQUEST.currentTick,
              tick_range: REQUEST.tickRange,
              range_min: Number.isFinite(parsedMin) ? parsedMin : null,
              range_max: Number.isFinite(parsedMax) ? parsedMax : null,
            };
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              const message = await response.text();
              throw new Error(message || "API error");
            }
            const data = await response.json();
            setDistributionData(data);
          } catch (err) {
            setDistributionError(err.message || "Failed to load data.");
            setDistributionData(null);
          } finally {
            setDistributionLoading(false);
          }
        };

        const fetchAllocate = async () => {
          setAllocateLoading(true);
          setAllocateError("");
          try {
            const payload = {
              pool_address: REQUEST.poolAddress,
              rede: REQUEST.rede,
              amount: depositUsd,
              range1: rangeMin,
              range2: rangeMax,
            };
            const response = await fetch(allocateUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              const message = await response.text();
              throw new Error(message || "API error");
            }
            const data = await response.json();
            setAllocateData(data);
          } catch (err) {
            setAllocateError(err.message || "Failed to load data.");
            setAllocateData(null);
          } finally {
            setAllocateLoading(false);
          }
        };

        const fetchPoolPrice = async () => {
          setPoolPriceLoading(true);
          setPoolPriceError("");
          try {
            const response = await fetch(
              `${poolPriceUrl}?pool_id=${REQUEST.poolId}&days=${timeframeDays}`,
              {
                method: "GET",
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              }
            );
            if (!response.ok) {
              const message = await response.text();
              throw new Error(message || "API error");
            }
            const data = await response.json();
            setPoolPriceData(data);
          } catch (err) {
            setPoolPriceError(err.message || "Failed to load data.");
            setPoolPriceData(null);
          } finally {
            setPoolPriceLoading(false);
          }
        };

        useEffect(() => {
          fetchDistribution();
          fetchAllocate();
        }, []);

        useEffect(() => {
          fetchPoolPrice();
        }, [timeframeDays]);

        useEffect(() => {
          if (!hasMountedRef.current) {
            hasMountedRef.current = true;
            return;
          }
          if (allocateDebounceRef.current) {
            clearTimeout(allocateDebounceRef.current);
          }
          allocateDebounceRef.current = setTimeout(() => {
            if (!Number.isFinite(Number(depositUsd))) {
              return;
            }
            fetchAllocate();
          }, 400);
          return () => {
            if (allocateDebounceRef.current) {
              clearTimeout(allocateDebounceRef.current);
            }
          };
        }, [depositUsd]);

        const token0 = distributionData?.pool?.token0 || allocateData?.token0_symbol || "TOKEN0";
        const token1 = distributionData?.pool?.token1 || allocateData?.token1_symbol || "TOKEN1";
        const feeTier = distributionData?.pool?.fee_tier ?? allocateData?.taxa ?? null;
        const token0Decimals = distributionData?.pool?.token0_decimals ?? null;
        const token1Decimals = distributionData?.pool?.token1_decimals ?? null;
        const rangeBounds = useMemo(() => {
          if (!distributionData?.data?.length) return { min: null, max: null };
          const prices = distributionData.data
            .map((point) => Number(point.price))
            .filter((value) => Number.isFinite(value));
          if (!prices.length) return { min: null, max: null };
          return { min: Math.min(...prices), max: Math.max(...prices) };
        }, [distributionData]);

        return (
          <>
            <div className="stack">
              <EstimatedFees />
              <LiquidityPriceRange
                rangeMin={rangeMin}
                rangeMax={rangeMax}
                setRangeMin={setRangeMin}
                setRangeMax={setRangeMax}
                onApply={fetchDistribution}
                bounds={rangeBounds}
                timeframeDays={timeframeDays}
                setTimeframeDays={setTimeframeDays}
                feeTier={feeTier}
                token0Decimals={token0Decimals}
                token1Decimals={token1Decimals}
              />
              <DepositAmount
                token0={token0}
                token1={token1}
                depositUsd={depositUsd}
                setDepositUsd={setDepositUsd}
                allocateData={allocateData}
                loading={allocateLoading}
                error={allocateError}
                onCalculate={fetchAllocate}
              />
            </div>
            <div className="stack">
              <LiquidityChart
                apiData={distributionData}
                loading={distributionLoading}
                error={distributionError}
                rangeMin={rangeMin}
                rangeMax={rangeMax}
                setRangeMin={setRangeMin}
                setRangeMax={setRangeMax}
                onApply={fetchDistribution}
              />
              <PoolPriceChart
                apiData={poolPriceData}
                loading={poolPriceLoading}
                error={poolPriceError}
                rangeMin={rangeMin}
                rangeMax={rangeMax}
                token0={token0}
                token1={token1}
              />
            </div>
          </>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<Page />);
    </script>
  </body>
</html>
